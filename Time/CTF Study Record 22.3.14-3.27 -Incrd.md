# 学习记录22.3.14-3.27 -Incrd

## 格密码学（Lattice-based Crypto）

对于格密码的介绍，推荐由 b 站 up 主 刘巍然-学酥 翻译的视频系列 [2012年BIU密码学冬令营-01-Introduction to Lattices（中文字幕）](https://www.bilibili.com/video/BV1re411W7vA/)，我也是藉由这几个视频对格密码有了初步的了解 。  
再贴两篇相对适合入门的文章：  
格密码学与 LWE 问题：<https://zhuanlan.zhihu.com/p/150920501>  
LLL 算法：<https://zhuanlan.zhihu.com/p/269524920>  
结合视频和文章，我至少花费了 3 天时间才对 LLL 算法及其算法输出有了一个初步的认识。  

## SUSCTF InverseProblem

观察题目很容易得知，这是一个 N = 85 的 LWE 搜索问题，其目前可知的方法应该是只有 LLL 算法。  
根据 $\vec{b}=Ax+\vec{e}$  
其中 $\vec{e}$ 即为一个很小的误差向量  
构造一个 (n+1) * (n+1)矩阵  
$$\begin{pmatrix}
A&E\\
b&0
\end{pmatrix}$$  
由于向量维度和大小较小，可以应用 LLL 算法找出最短向量 $\vec{e}$  
sage 中 Matrix 的 LLL 方法已经集成了相关功能，直接使用即可。

exp

```python
import numpy as np

def gravity(n,d=0.25):
    A=np.zeros([n,n])
    for i in range(n):
        for j in range(n):
            A[i,j]=d/n*(d**2+((i-j)/n)**2)**(-1.5)
    return A

b=np.loadtxt('b.txt')
n=len(b)
b=vector(QQ,b.tolist())
A=matrix(QQ,gravity(n).tolist())
M=block_matrix(QQ,[[A,zero_matrix(n,1)],[matrix(b),matrix([1e-16])]])
L=M.LLL()
x=A\(b-L[0][:-1])
flag=bytes(x).decode()
print(flag)
```

## HFCTF2022 RRSSAA

RRSSAA.py

```python
from Crypto.Util.number import getPrime, inverse, GCD, bytes_to_long
from random import randint
from secret import hint, flag

def seq(r, k):
    v = [r, 2]
    for i in range(1, k):
        v = [r*v[0]-v[1], v[0]]
    ret = v[0] if k != 0 else v[1]
    return ret

def encrypt(m, e, n):
    while True:
        r = randint(1, n - 1)
        if r != 2 and r != n - 2 and GCD(r, n) == 1:
            break
    v = seq(r, e)
    print(r)
    return ((1 + m*n) * v) % n**2

def go(beta, msg):
    nbits = 1024
    delta = 0.63

    p = getPrime(nbits // 2)
    q = next_prime(p + (1 << int(nbits * beta)))
    n = p * q
    phi = (p**2 - 1) * (q**2 - 1)

    while True:
        d = getPrime(int(nbits * delta))
        if GCD(d, phi) == 1:
            e = inverse(d, phi)
            if GCD(e, phi) == 1:
                break

    m = bytes_to_long(msg)
    c = int(encrypt(m, e, n))

    print(f"n = {n}")
    print(f"e = {e}")
    print(f"c = {c}")

go(0.33, hint)
go(0.44, flag)

'''
n = 122774778628333786198247673730199699244621671207929503475974934116435291656353398717362903500544713183492877018211738292001516168567879903073296829793548881467270228989482723510323780292947403861546283099122868428902480999485625751961457245487615479377459707992802193391975415447673215862245349068018710525679
e = 7105408692393780974425936359246908629062633111464343215149184058052422839553782885999575538955213539904607968494147112651103116202742324255190616790664935322773999797774246994193641076154786429287567308416036562198486649223818741008968261111017589015617705905631979526370180766874051731174064076871339400470062519500450745667838729104568633808272577378699913068193645578675484681151593983853443489561431176000585296710615726640355782811266099023653898050647891425956485791437516020367967793814415345332943552405865306305448753989707540163585481006631816856260061985275944250758886027672221219132999488907097750048011
c = 2593129589804979134490367446026701647048897831627696427897506570257238733858989741279626614121210703780002736667183915826429635213867589464112850355422817678245007337553349507744893376944140333333044928907283949731124795240808354521353751152149301719465724014407412256933045835977081658410026081895650068864922666975525001601181989114436054060461228877148361720945120260382962899756912493868467226822547185396096960560068874538680230073168773182775945272726468512949751672553541335307512429217493003429882831235199830121519272447634533018024087697385363918421438799206577619692685090186486444886371979602617584956259
n = 59969098213446598961510550233718258878862148298191323654672950330070587404726715299685997489142290693126366408044603303463518341243526241117556011994804902686998166238333549719269703453450958140262475942580009981324936992976252832887660977703209225426388975233018602730303262439218292062822981478737257836581
e = 970698965238639683403205181589498135440069660016843488485401994654202837058754446853559143754852628922125327583411039117445415303888796067576548626904070971514824878024057391507617988385537930417136322298476467215300995795105008488692961624917433064070351961856959734368784774555385603000155569897078026670993484466622344106374637350023474339105113172687604783395923403613555236693496567851779400707953027457705617050061193750124237055690801725151098972239120476113241310088089420901051617493693842562637896252448161948655455277146925913049354086353328749354876619287042077221173795354616472050669799421983520421287
c = 2757297249371055260112176788534868300821961060153993508569437878576838431569949051806118959108641317578931985550844206475198216543139472405873345269094341570473142756599117266569746703013099627523306340748466413993624965897996985230542275127290795414763432332819334757831671028121489964563214463689614865416498886490980692515184662350519034273510244222407505570929178897273048405431658365659592815446583970229985655015539079874797518564867199632672678818617933927005198847206019475149998468493858071672920824599672525667187482558622701227716212254925837398813278836428805193481064316937182435285668656233017810444672
'''
```

注意到 `q = next_prime(p + (1 << int(nbits * beta)))`，  
有 $n = p *(p + 1 << int(nbits* beta) + i)$  
枚举 i 求解 p 即可。

```python
n = 59969098213446598961510550233718258878862148298191323654672950330070587404726715299685997489142290693126366408044603303463518341243526241117556011994804902686998166238333549719269703453450958140262475942580009981324936992976252832887660977703209225426388975233018602730303262439218292062822981478737257836581
nbits = 1024
delta = 0.63
beta = 0.44
temp = 1 << int(nbits* beta)
x = polygen(QQ)
for i in range(2000):
    f = x * (x + temp + i) - n
    if f.roots():
        p = f.roots()[0][0]
        print(p)
        q = n / p
        print(q)
'''
p = 7743971733771153102128801312798743998017713722732925283466018690899116898707556486947918196848489007935614742583856884731087798825462330340492923214926391
q = 7743971733771153105036156209981171560215008954284943420880584133648389139833517283670475349302080701240378945438911146974137885250527042074631329729385091
'''
```

通过 google "RSA (p2-1)(q2-1)" 可得知该算法是 RSA 的一个变种，利用了 LUC cryptosystem，继续搜索找到提出该种的算法的论文：<https://www.math.u-bordeaux.fr/~gcastagn/publi/crypto_quad.pdf> 获取解密算法。  

```python
from sage.rings.finite_rings.integer_mod import lucas
import gmpy2
from Crypto.Util.number import long_to_bytes
import sys
sys.setrecursionlimit(5000)

N = 59969098213446598961510550233718258878862148298191323654672950330070587404726715299685997489142290693126366408044603303463518341243526241117556011994804902686998166238333549719269703453450958140262475942580009981324936992976252832887660977703209225426388975233018602730303262439218292062822981478737257836581
E = 970698965238639683403205181589498135440069660016843488485401994654202837058754446853559143754852628922125327583411039117445415303888796067576548626904070971514824878024057391507617988385537930417136322298476467215300995795105008488692961624917433064070351961856959734368784774555385603000155569897078026670993484466622344106374637350023474339105113172687604783395923403613555236693496567851779400707953027457705617050061193750124237055690801725151098972239120476113241310088089420901051617493693842562637896252448161948655455277146925913049354086353328749354876619287042077221173795354616472050669799421983520421287
C = 2757297249371055260112176788534868300821961060153993508569437878576838431569949051806118959108641317578931985550844206475198216543139472405873345269094341570473142756599117266569746703013099627523306340748466413993624965897996985230542275127290795414763432332819334757831671028121489964563214463689614865416498886490980692515184662350519034273510244222407505570929178897273048405431658365659592815446583970229985655015539079874797518564867199632672678818617933927005198847206019475149998468493858071672920824599672525667187482558622701227716212254925837398813278836428805193481064316937182435285668656233017810444672
P = 7743971733771153102128801312798743998017713722732925283466018690899116898707556486947918196848489007935614742583856884731087798825462330340492923214926391
Q = 7743971733771153105036156209981171560215008954284943420880584133648389139833517283670475349302080701240378945438911146974137885250527042074631329729385091

D = C**2 - 4
LS_P = gmpy2.legendre(D,P)
LS_Q = gmpy2.legendre(D,Q)

d = gmpy2.invert(E, gmpy2.lcm(P-LS_P,Q-LS_Q))

inv_q,inv_p = inverse_mod(P,Q), inverse_mod(Q,P)
rp = lucas(k = inverse_mod(E, P-LS_P), P=C, Q=1, n=P)[0]
rq = lucas(k = inverse_mod(E, Q-LS_Q), P=C, Q=1, n=Q)[0]
r = crt(int(rp), int(rq), P, Q)
vp = lucas(k = E, P = r,Q = 1,n = P * P)[0]
tmp_p = C * inverse_mod(int(vp), P*P) % (P*P)
tmp_p = int(tmp_p -1 ) // P
mp=int(tmp_p * inv_p % P)
vq=lucas(k = E,P = r, Q = 1, n = Q * Q)[0]
tmp_q = c * inverse_mod(int(vq), Q * Q) % (Q * Q)
tmp_q = int(tmp_q - 1) // Q
mq = int(tmp_q * inv_q % Q)
flag = crt(mp, mq, P, Q)
print(long_to_bytes(flag))
# b'HFCTF{5eb34942-bd0d-4efd-b0e1-a73225d92678}'
```

## BUUCTF RSA2

若 dp 泄露，则能在 $\Omicron(e)$ 时间内破解密文  
$d_p \equiv d\ mod\ (p-1)$  
$\Rightarrow d_p*e\equiv d*e\ mod\ (p-1)$  
$\Rightarrow d*e = k_1*(p-1)+d_p*e$  
根据  
$d*e\equiv1\ mod\ \phi(n)$  
$\phi(n)=(p-1)*(q-1)$  
有  
$k_1*(p-1)+d_p*e\equiv 1\ mod\ (p-1)*(q-1)$  
$\Rightarrow k_1*(p-1)+d_p*e=k_2*(p-1)*(q-1)+1$  
$\Rightarrow d_p*e=[k_2*(q-1)-k_1]*(p-1)+1$  
设 $e>[k_2*(q-1)-k_1]$ 为 $x$  
其中 $d_p<p-1$  
故 $e>x$  
故可以通过枚举 $x\in (0, e)$  
验证 $(d_p*e-1)/x$ 是否为整数，以及 $(d_p*e-1)/x+1$ 是否能整除 $n$ 来判断枚举正误。  

该题即考察这一点。  

```python
import gmpy2
from Crypto.Util.number import long_to_bytes
e = 65537
n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113
dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657

c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751

for i in range(1, e):
    if (dp * e - 1) % i == 0:
        if n % (((dp * e - 1) // i) + 1) == 0:
            p = ((dp * e - 1) // i) + 1
            q = n // (((dp * e - 1) // i) + 1)
            phi = (q - 1) * (p - 1)
            d = gmpy2.invert(e, phi)
            m = pow(c, d, n)


print(long_to_bytes(m))
```

## NSSCTF public

task.py

```python
import os
from Crypto.Util.number import *
flag=b"NSSCTF{xxxxxxxxxxxxxxxxxxx}"
p = getPrime(2048)
q = getPrime(2048)
n = p*q
g = n+1
flag = flag + os.urandom(256)
m = bytes_to_long(flag)
assert m < n
c=(pow(g,p,n*n)*pow(m,n,n*n))%(n*n)
print(f"c={str(c)}")
print(f"n={str(n)}")
print(f"hint={str(pow(m,n,n*n))}")
# c=218076151021560547051903316719541222512040541728274127251955864973204319200312422995983092104505370830336341646283643290975865810979693431665790610118752578450560322701464606111124759353729454729357651736630354926734261137232304018105525402480409214739463624926019853406667257471858400554068936984966255122726345392299611192889869061539625603262461395069803838256649227551122691722958477064737646079234633593322257264277828874899605785719884582898801922036376706945214557655573105936069927519342707813584133447394527727777145289236041783964596526172298751923527410923728437653793368452092818162677292173126395038239746952564824349029187021070624008127312777783389153721156471730690460245726539173442219919067086198412985379251064006364545842890512676104195964096685904104471607447579133813262242889948684214615216415152003486684332654021763372875688811108164167029372542655680239691864011325001804416649090546652965592245015233937378914902555020997254559783431091213187054225512285704706127222748135840936979571164239968858574619878355623067035562073147836429462588372618500946665592533980646179287203705864082701267348885216165672773119373427706470575290690902668785242467233967870570261108990892859880739698792351646244754952340844420919259404502699266393058426943569348443212550646905609608670176752388829848639990144513783071090027192962534454341704209113094332822171724354423757760205937173503650126923081671379294681026909824698111163520911268295889474804858820122835834292711776643387277793548733641809948674628119693459864760337483163877679917119388740268787073315582536101385769332216844206772200893152057186765390268976281904057200764887141067277637744939424349347335952574178492737111320884889894593413406720620482887249419382551684677812936351975305964980443771310389160311391859989139144435489943187361252326617436405569045786172471146825826484820533463066934499480104433398977611810330276369147938097117995654985458513989302241106332776904067311803420489090552556891879767682415265560743407340298578130798877648570926192953127574474259716781135801273211777116319348356510073635809816358623224620898024473581877733194648312939500788032519396047197931401057492369464362250728505049498537131676040902419082386902837490490020207391112191256297932073021141841637862479797419191517126847743253818063471644376196087415026020405982443713386674133996026381008967344619818015476575693412862275373303754013892689230528546297224836909468991043799205998787941893011
# n=508649864931677614732467390772427961758931524996950943172348989353779413500135745017318030372818346445171787306774776609051270954621980771071637593801560166625137373096310055034937710873339570248386417692379532713565448110999149898224125057983565314582568870217037082321220190178702247284057805478222196862321877126877541221804916630403210745798454726695767965708773814502024042373335280648703042654755304969849832318086242798067639199224298659205981289856966590499810461072473369452077687615913217546268362501813809748922922532657782215807173319693469430751556310985767810712372068465527832726893651833030643914873945580271625080157996808574695857605733101549978621472016493582602814890278818563043847095493265778824174731054566468708287724290549925230267719117266452407869862605078436659020887227224470196270187491398217001451889275579626459491632506953638949085966203707446055610214983015428316166700670710716910016807567113694397559364621848368518820842900845963635710936101678917277407976769668789284143702572735353391307624460327339616496606065042109014043456540221432729574605562610831787594345569772727113605355252600129915926507232161710531913156415953128254338208741867773085355435238760994755555830964013004019492562245961
# hint=218453179086923289943807203202770838925178689627774745147232020515098516891161432630028304346664762962142685215503546042472463188085210756898964960254583869432945520650866749585786670220495127010275938757711518963512690357966318771229029024139860779906436335668507703089169058834533472932888386221671186182247869434699020350251916212956639268455849140594527951127570312231046210122761381292092058171708887595484453711631828228850043342993869671675498781490707220852504338423236844200845629493885003815571053367960570828719514793961666314203716137708394529735950110878173175859966298104855781891314256393660478947857997049309347664916363312769426872393903240797057291513182057786294193463281179876929436423970304992964378978343703058273610599094670858299390115880959442514513002687898361714995376183382702580310860520166550246905769724461107221385567718477106980293610194354260662299313387637029454859051754049141731708862005007657254777005078937290648653252057172789665484106225904252249322285164277069353595858401391763857781471982430400812430485462777863701578165740021651239264400111602346875691919587562776319002092593590043298682899772829734368041057265219520645505796166918571599787733464916168997021422429642875880015201743138557239246816614645961943942384226721696842364578221142494114967457346538723563534281835490913459152865031135512888020156712332950698315471031328945767161582387501768383019764191345069522790270253976284543970378444427727423121536104008553289510510497088596599741651012409020454471902200942494893254608355219933431097693790764370965829619433976045850073467615077879096698409574487772631069225578624386542659818683559823001358916184145187794138636007200677181455572920942709512649217555102476437241677652845050079961562071604521307752725300453167225947534296744839161286409625003203181858982730609149419917332043428767843293277924022007390853988328511663307394805322715579362345649842431371200748639996476587970393904239732072852670279076966635546790856059886353247283187091483814130965265452117641315707359747672993447721009270939662160468115475733881984431822454194850017395548046798675473636140217840418467588166347095543815767317284635513061287105795015042775738353765062476084211922890124244419037796630154403434882572164730631883001098922170198642065216541425903144234820480236095640278292837060194123091442480170728800340689332104613912950234195039809087610879082689821270573215009809335626725761798981628604037461376378712686098
```

核心语句 `c = (pow(g,p,n*n)*pow(m,n,n*n))%(n*n)`，其中 `g = c + 1`  
故  
$g^p\ mod\ n^2$  
$\Rightarrow (n+1)^p\ mod\ n^2$  
对 $(n+1)^p$ 进行二项式展开  
上式可化为  
$n*p+1\ mod\ n^2$  
题目给出了 $hint$ 的值  
$n*p+1\ mod\ n^2 = c*hint^{-1}\ mod\ n^2$  
得出 $X = n*p+1\ mod\ n^2$ 的值  
$(X-1)/n=p$  
即可成功分解 $n$  
观察式 $hint = m^n\ mod\ n^2$  
由于 $n$ 与 $\phi(n^2) = p(p-1)q(q-1)$  
$hint\ mod\ n = (m^n\ mod\ n^2)\ mod\ n = m^n\ mod\ n$  
$hint \equiv m^n\ mod\ n$  
视指数 $n$ 为 $e$，故可求得 $inverse\_mod(e, (p-1)(q-1))$  

exp:

```py
import gmpy2
from Crypto.Util.number import long_to_bytes
c=218076151021560547051903316719541222512040541728274127251955864973204319200312422995983092104505370830336341646283643290975865810979693431665790610118752578450560322701464606111124759353729454729357651736630354926734261137232304018105525402480409214739463624926019853406667257471858400554068936984966255122726345392299611192889869061539625603262461395069803838256649227551122691722958477064737646079234633593322257264277828874899605785719884582898801922036376706945214557655573105936069927519342707813584133447394527727777145289236041783964596526172298751923527410923728437653793368452092818162677292173126395038239746952564824349029187021070624008127312777783389153721156471730690460245726539173442219919067086198412985379251064006364545842890512676104195964096685904104471607447579133813262242889948684214615216415152003486684332654021763372875688811108164167029372542655680239691864011325001804416649090546652965592245015233937378914902555020997254559783431091213187054225512285704706127222748135840936979571164239968858574619878355623067035562073147836429462588372618500946665592533980646179287203705864082701267348885216165672773119373427706470575290690902668785242467233967870570261108990892859880739698792351646244754952340844420919259404502699266393058426943569348443212550646905609608670176752388829848639990144513783071090027192962534454341704209113094332822171724354423757760205937173503650126923081671379294681026909824698111163520911268295889474804858820122835834292711776643387277793548733641809948674628119693459864760337483163877679917119388740268787073315582536101385769332216844206772200893152057186765390268976281904057200764887141067277637744939424349347335952574178492737111320884889894593413406720620482887249419382551684677812936351975305964980443771310389160311391859989139144435489943187361252326617436405569045786172471146825826484820533463066934499480104433398977611810330276369147938097117995654985458513989302241106332776904067311803420489090552556891879767682415265560743407340298578130798877648570926192953127574474259716781135801273211777116319348356510073635809816358623224620898024473581877733194648312939500788032519396047197931401057492369464362250728505049498537131676040902419082386902837490490020207391112191256297932073021141841637862479797419191517126847743253818063471644376196087415026020405982443713386674133996026381008967344619818015476575693412862275373303754013892689230528546297224836909468991043799205998787941893011
n=508649864931677614732467390772427961758931524996950943172348989353779413500135745017318030372818346445171787306774776609051270954621980771071637593801560166625137373096310055034937710873339570248386417692379532713565448110999149898224125057983565314582568870217037082321220190178702247284057805478222196862321877126877541221804916630403210745798454726695767965708773814502024042373335280648703042654755304969849832318086242798067639199224298659205981289856966590499810461072473369452077687615913217546268362501813809748922922532657782215807173319693469430751556310985767810712372068465527832726893651833030643914873945580271625080157996808574695857605733101549978621472016493582602814890278818563043847095493265778824174731054566468708287724290549925230267719117266452407869862605078436659020887227224470196270187491398217001451889275579626459491632506953638949085966203707446055610214983015428316166700670710716910016807567113694397559364621848368518820842900845963635710936101678917277407976769668789284143702572735353391307624460327339616496606065042109014043456540221432729574605562610831787594345569772727113605355252600129915926507232161710531913156415953128254338208741867773085355435238760994755555830964013004019492562245961
hint=218453179086923289943807203202770838925178689627774745147232020515098516891161432630028304346664762962142685215503546042472463188085210756898964960254583869432945520650866749585786670220495127010275938757711518963512690357966318771229029024139860779906436335668507703089169058834533472932888386221671186182247869434699020350251916212956639268455849140594527951127570312231046210122761381292092058171708887595484453711631828228850043342993869671675498781490707220852504338423236844200845629493885003815571053367960570828719514793961666314203716137708394529735950110878173175859966298104855781891314256393660478947857997049309347664916363312769426872393903240797057291513182057786294193463281179876929436423970304992964378978343703058273610599094670858299390115880959442514513002687898361714995376183382702580310860520166550246905769724461107221385567718477106980293610194354260662299313387637029454859051754049141731708862005007657254777005078937290648653252057172789665484106225904252249322285164277069353595858401391763857781471982430400812430485462777863701578165740021651239264400111602346875691919587562776319002092593590043298682899772829734368041057265219520645505796166918571599787733464916168997021422429642875880015201743138557239246816614645961943942384226721696842364578221142494114967457346538723563534281835490913459152865031135512888020156712332950698315471031328945767161582387501768383019764191345069522790270253976284543970378444427727423121536104008553289510510497088596599741651012409020454471902200942494893254608355219933431097693790764370965829619433976045850073467615077879096698409574487772631069225578624386542659818683559823001358916184145187794138636007200677181455572920942709512649217555102476437241677652845050079961562071604521307752725300453167225947534296744839161286409625003203181858982730609149419917332043428767843293277924022007390853988328511663307394805322715579362345649842431371200748639996476587970393904239732072852670279076966635546790856059886353247283187091483814130965265452117641315707359747672993447721009270939662160468115475733881984431822454194850017395548046798675473636140217840418467588166347095543815767317284635513061287105795015042775738353765062476084211922890124244419037796630154403434882572164730631883001098922170198642065216541425903144234820480236095640278292837060194123091442480170728800340689332104613912950234195039809087610879082689821270573215009809335626725761798981628604037461376378712686098
inv = inverse_mod(hint, n*n)

gpnn = (c * inv) % (n*n)
p = (gpnn-1)//n
q = n // p
m = pow(hint, inverse_mod(n, (p-1)*(q-1)), n)
print(m)
print(long_to_bytes(m))
```

## NSSCTF rrssaa2

```py
from Crypto.Util.number import *
import random
import libnum
import gmpy2

def gen():
    p = 1801 * random.getrandbits(1012) + 1
    while not isPrime(p):
        p = 1801 * random.getrandbits(1012) + 1
    return p
p=gen()
q=gen()
e=1801
n=p*q
flag='NSSCTF{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}'
flag=flag+'yhe92871899hihiohh97709ujojl;lhdiwoqu903YE98Y299HDY8W9EYRW8!$$%!$!$FSR@#$@%FSEGDRYERYHRWER@$%^$^DGTW%$^&GRWR@$%@FASFSFQFSTGW#TWGARWQ$@%WGVDSGADQR@%TGVDSFASDATWEGHWE%@$GSDVSFQATY$^#^%@$!RAFSDGDRTW'

c = pow(m, e, n)
print('e=',e)
print('p=',p)
print('q=',q)
print('c=',c)

#e= 1801
#p= 49610229352589717245227429186510630298995334563536199979797365135356894947505595171590737127611751124743823204969291853243936699113293137172961540731655194113111189561603261168928406442577570919901769348742992633428864861175880441682752947688509869668929473479230018031647980097396415380123118521799468844841
#q= 21081926656979729045764441706195868361643779935106260715219328461497406780587336009385210898093496090213306812904410650499587043699660339207567766840318127296396962037273317168795761421233687815992929975284592353117739413561939283754964442896468496199833988666060155459156116345763999855126020972915904618043
#c= 601596145172542477058917394071994325109856881057412872218601643742101914635753765731910337249806643258952637146341530783703613931109366648847232809553067941206928974141651198815184695746636818122414926015513095322872645068410957200062317958684872682628646759817233433643987003499153702624673493727886566639667597997520471371146056861227114668317633291934130573158877960548655006208725827943739971068608175370661619328559766977175575896437656636083179668805135271793023165492681941002853661303072959879197775224449456951125268328000206540965011249895216257583247180682482954741912101069920760903900864428405997751199


```

给出 $p, q$，但是 $e$ 与 $\phi(n)$ 不互素，考察 AMM 开根，分别计算  
$c_p=c\ mod\ p,\ c_q=c\ mod\ q$  
$c = m^e\ mod\ n$  
$\Rightarrow c_p=m^e\ mod\ p,\ c_q=m^e\ mod\ q$  
对上式开根  
对结果进行 CRT 组合，以 NSSCTF 判别 flag。  

exp:

```py
import random
import math
import time
import multiprocessing
from Crypto.Util.number import *
from sympy.ntheory.modular import crt


def AMM(x, e, p):
    y = random.randint(1, p - 1)
    while pow(y, (p - 1) // e, p) == 1:
        y = random.randint(1, p - 1)
    # p-1 = e^t*s
    t = 1
    s = 0
    while p % e == 0:
        t += 1
        print(t)
    s = p // (e**t)
    # s|ralpha-1
    k = 1
    while ((s * k + 1) % e != 0):
        k += 1
    alpha = (s * k + 1) // e
    # 计算 a = y^s b = x^s h =1
    # h 为 e 次非剩余部分的积
    a = pow(y, (e**(t - 1)) * s, p)
    b = pow(x, e * alpha - 1, p)
    c = pow(y, s, p)
    h = 1
    #
    for i in range(1, t - 1):
        d = pow(b, e**(t - 1 - i), p)
        if d == 1:
            j = 0
        else:
            j = -math.log(d, a)
        b = b * (pow(pow(c, e, p), j, p))
        h = h * pow(c, j, p)
        c = pow(c, e, p)
    # return (pow(x, alpha * h, p)) % p
    root = (pow(x, alpha * h, p)) % p
    roots = set()
    for i in range(e):
        mp2 = root * pow(a, i, p) % p
        assert (pow(mp2, e, p) == x)
        roots.add(mp2)
    return roots


def CRTPAIR(p, q, mp, mq):
    start = time.time()
    for mpp in mp:
        for mqq in mq:
            try:
                res = int(crt((p, q), (mpp, mqq))[0])
                solution = long_to_bytes(res)
                if b'NSSCTF' in solution:
                    print(solution)
                    print("Finished in {} seconds.".format(time.time() -
                                                           start))
            except:
                continue


def main():
    e = 1801
    p = 49610229352589717245227429186510630298995334563536199979797365135356894947505595171590737127611751124743823204969291853243936699113293137172961540731655194113111189561603261168928406442577570919901769348742992633428864861175880441682752947688509869668929473479230018031647980097396415380123118521799468844841
    q = 21081926656979729045764441706195868361643779935106260715219328461497406780587336009385210898093496090213306812904410650499587043699660339207567766840318127296396962037273317168795761421233687815992929975284592353117739413561939283754964442896468496199833988666060155459156116345763999855126020972915904618043
    c = 601596145172542477058917394071994325109856881057412872218601643742101914635753765731910337249806643258952637146341530783703613931109366648847232809553067941206928974141651198815184695746636818122414926015513095322872645068410957200062317958684872682628646759817233433643987003499153702624673493727886566639667597997520471371146056861227114668317633291934130573158877960548655006208725827943739971068608175370661619328559766977175575896437656636083179668805135271793023165492681941002853661303072959879197775224449456951125268328000206540965011249895216257583247180682482954741912101069920760903900864428405997751199

    n = p * q

    cp = c % p
    cq = c % q
    mp = list(AMM(cp, e, p))
    mq = list(AMM(cq, e, q))

    print("Start CRT...")

    for i in range(0, len(mq), len(mq) // 8 + 1):
        proc = multiprocessing.Process(target=CRTPAIR, args=(p, q, mp, mq[i:i + len(mq) // 8 + 1]))
        proc.start()

if __name__ == "__main__":
    main()
```
