# 学习记录22.1.24-1.30 -Incrd

## RSA 低加密指数攻击

适用于 e 的值非常小时（通常为 3）  
此时加密公式为  
m$^{3}$ mod n = c  
等价于 m$^{3}$ ≡ c (mod n)  
其中 c mod n 可直接求出 c，令 MDO = c mod n，则 m$^{3}$ mod n = MOD，可得出  
m$^{3}$ = kn + MOD, k = 1, 2, 3...
m = (kn + MOD)$^{1/3}$, k = 1, 2, 3...
由于 m 也是整数，所以我们只需要找到一个 k 使得 m 为一个整数即可，由于开方数较小，故容易在有限时间内穷举出 k。  
下面是一道例题  

## picoCTF Mini RSA WP

Description:  
What happens if you have a small exponent? There is a twist though, we padded the plaintext so that (M ** e) is just barely larger than N. Let's decrypt this:  
ciphertext:

```text
N: 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
e: 3

ciphertext (c): 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146956044568639690002921620304969196755223769438221859424275683828638207433071955615349052424040706261639770492033970498727183446507482899334169592311953247661557664109356372049286283480939368007035616954029177541731719684026988849403756133033533171081378815289443019437298879607294287249591634702823432448559878065453908423094452047188125358790554039587941488937855941604809869090304206028751113018999782990033393577325766685647733181521675994939066814158759362046052998582186178682593597175186539419118605277037256659707217066953121398700583644564201414551200278389319378027058801216150663695102005048597466358061508725332471930736629781191567057009302022382219283560795941554288119544255055962

```

now the crack is:

```python
import gmpy2
import binascii
import libnum
n = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
e = 3
c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146956044568639690002921620304969196755223769438221859424275683828638207433071955615349052424040706261639770492033970498727183446507482899334169592311953247661557664109356372049286283480939368007035616954029177541731719684026988849403756133033533171081378815289443019437298879607294287249591634702823432448559878065453908423094452047188125358790554039587941488937855941604809869090304206028751113018999782990033393577325766685647733181521675994939066814158759362046052998582186178682593597175186539419118605277037256659707217066953121398700583644564201414551200278389319378027058801216150663695102005048597466358061508725332471930736629781191567057009302022382219283560795941554288119544255055962

# 计算 c mod n
mod = c % n


def test():
    k = 0
    while(1):
        res, is_exact = gmpy2.iroot(k * n + mod, e)
        if is_exact:
            print(f'k = {k}\nres = {res}')
            break
        k = k + 1
    return res


res = int(test())
plaintxt = libnum.n2s(res)
print(f'plaintxt = {plaintxt}')
```

输出：

```text
k = 3533
res = 1787330808968142828287809319332701517353332911736848279839502759158602467824780424488141955644417387373185756944952906538004355347478978500948630620749868180414755933760446136287315896825929319145984883756667607031853695069891380871892213007874933611243319812691520078269033745367443951846845107464675742664639073699911281377201069777277
hex(res) = 0x20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020207069636f4354467b655f7368307531645f62335f6c41726733725f36653265366264617d
plaintxt =                                                                                                         picoCTF{e_sh0u1d_b3_lArg3r_6e2e6bda}
```

还可以看到明文用空格做了填充。

## HGAME English Novel

Description:  
为了学好四六级，协会里某不知名的康师傅决定通过看英文小说来提高自己的英语水平。  
可不知道为什么，下载来的小说竟然都被打乱并加密了。  
他费尽千辛万苦重要找到了一部分小说的原文，你能帮帮他么？  
给出了一个 encrypt 文件夹，里面是加密后的内容，并且内容片断被打乱，original 文件夹里是小说原文片断，一个 encrypt.py 文件，一个flag.enc 文件。  
encrypt.py:

```python
def encrypt(data, key):
    assert len(data) <= len(key)
    result = ""
    for i in range(len(data)):
        if data[i].isupper():
            result += chr((ord(data[i]) - ord('A') + key[i]) % 26 + ord('A'))
        elif data[i].islower():
            result += chr((ord(data[i]) - ord('a') + key[i]) % 26 + ord('a'))
        else:
            result += data[i]
    return result
```

一开始还以为是维吉尼亚加密，试了各种方法后都不对，仔细看注意到 `assert len(data) <= len(key)` 即密钥长度是大于明文长度的，然后我又以为整片文章是一起加密的，既然这样那密钥就无规律可循了，成了一次性密码本加密，但是后来才发现想错了，在解题过程中我写下过如下脚本：

```python
import os

def Space_Pos(str1):
    space_pos = []
    for i in range(len(str1)):
        if str1[i] == ' ':
            space_pos.append(i)
    return space_pos


with open(r'D:\Operator\Download\HGAME\English Novel\original\part13.txt',"r") as part8_txt:
    str1 = part8_txt.read()
str1_space_pos = Space_Pos(str1)

path = r'D:\Operator\Download\HGAME\English Novel\encrypt'
files = os.listdir(path)

for file in files:
    if not os.path.isdir(file): # 判断是否是文件夹，不是文件夹才打开
        f = open(path+'\\'+file)
        str2 = f.read()
        str2_space_pos = Space_Pos(str2)
        if str2_space_pos == str1_space_pos:
            print(file) # part165.txt
            break

res = ''
for i in range(len(str1)):
    temp1 = str1[i]
    temp2 = str2[i]
    if temp1.isalpha():
        if ord(temp2) >= ord(temp1):
            res += chr(97 + ord(temp2) - ord(temp1))
        else:
            res += chr(97 + 26 - (ord(temp1) - ord(temp2)))
    else:
        res += '?'
print(res)

```

根据空格位置找出对应文本，再根据各位的偏移值打印出密钥，发现密钥并没有规律，此时我仍以为整篇文章是一起加密的，一筹莫展之际，我尝试把文章样本更换一下做个尝试，此时才发现文章实际上是一篇篇单独加密的，并且所用的密钥相同，所以根据多个文本样例很容易得到完整的密钥，用来解密 flag.enc中的内容，脚本如下：

```python
def decrypt(data, key):
    assert len(data) <= len(key)
    result = ""
    for i in range(len(data)):
        if data[i].isupper():
            result += chr((ord(data[i]) - ord('A') - key[i] + 26) % 26 + ord('A'))
        elif data[i].islower():
            result += chr((ord(data[i]) - ord('a') - key[i] + 26) % 26 + ord('a'))
        else:
            result += data[i]
    return result


data = r"xaawr{B0_d0l_cs0m_'Pp0mn-odn1vpabt_deqzcq'?}"
keystr = r"quakndyhyfwrrsfnqojfcpqauzsnhiwweaidlxzagddkciafn"
key = list(map(lambda x:ord(x) - ord('a'), keystr))
print(decrypt(data, key))
```

## Wiener’s attack

描述：  
如果满足：d<（1/3）* n **（1/4）  
那么一种基于连分数(一个数论当中的问题)的特殊攻击类型就可以危害 RSA 的安全。  

思路如下：  
在RSA中有式子：ed Ξ 1 (mod n) 推到公式变换为：  
**e/phi -k/d = 1/(dphi)**
因为p,q很大有φ(n)接近与n，e/n -k/d = 1/(d*n)  
又因为d\*n很大所以有e/n接近于k/d (e/n略大于k/d)  
计算e/n的连分数展开，依次算出每一个渐进分数。因为e/n > k/d 所以e/n 的渐进分数覆盖了k/d。也就是说e/n的渐进分数里有等于k/d的分数。接着验证k,d是否满足条件。  

算法过程：  

1. 通过对e/n进行连分数展开  
2. 然后依次求其渐进分数  
3. 遍历所有渐进分数如果找到了d的话，(ed-1)会整除phi,也就是存在k使得(ed-1)//k=φ(n),建立方程求p,q。(x$^{2}$−(p+q)∗x+pq=0这个方程的解就是p,q) 如果p*q==n则找到了d  
搬运代码  

```python
import gmpy2
import binascii

# numerator(n):分子, denominator(d)：分母
def t_cf(n, d):  # 将分数 x/y 转为连分数的形式
    res = []
    while d:
        res.append(n // d)
        n, d = d, n % d
    return res


def cf(sub_res):    # 得到渐进分数的分母和分子
    n, d = 1, 0
    for i in sub_res[::-1]:  # 从后面往前循环
        d, n = n, i * n + d
    return d, n


def list_fraction(x, y):     # 列出每个渐进分数
    res = t_cf(x, y)
    res = list(map(cf, (res[0:i] for i in range(1, len(res)))))  # 将连分数的结果逐一截取以求渐进分数
    return res


def get_pq(a, b, c):  # 由p+q和pq的值通过维达定理来求解p和q(解二元一次方程)
    par = gmpy2.isqrt(b * b - 4 * a * c)  # 由上述可得，开根号一定是整数，因为有解
    x1, x2 = (-b + par) // (2 * a), (-b - par) // (2 * a)
    return x1, x2


def wienerAttack(e, n):
    for (d, k) in list_fraction(e, n):  # 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数
        if k == 0:  # 可能会出现连分数的第一个为0的情况，排除
            continue
        if (e * d - 1) % k != 0:  # ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)
            continue

        phi = (e * d - 1) // k  # 这个结果就是 φ(n)
       
        px, qy = get_pq(1, n - phi + 1, n)

        if px * qy == n:
            p, q = abs(int(px)), abs(int(qy))  # 可能会得到两个负数，负负得正未尝不会出现
            d = gmpy2.invert(e, (p - 1) * (q - 1))  # 求ed=1 (mod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d
            return d
    print("求解d失败")
```

下面时一道例题。  

## picoCTF Dachshund Attacks

Description:  
What if d is too small? Connect with nc mercury.picoctf.net 36463.  
nc 连接后给出了 e, n, c(密文)的值可以直接使用 wienerAttack。  

```python
e = 75242567357074427700471272806018147473183941054313138902773337915664868445894430847456019905130810711857723416521525336049934977144185765954427722005455780582457560395562198985707749505842091020694280433989323023527061156168694217315329433077458035931854521068388714879534490147660519221516933900683984475841
n = 116420077719651382957358547097319618799402135340373866847337831958894854941002545696820755927945816420480553834588814459237735557500706053488064361463981274739564251605310666214662795096538925049043448212373273788795771524795901908091119848305338851379748602823283682421286970779346382638392501998667811306947
c = 55650176486873386738150732874136182182091865073919127538778105791493659054293290626175349543050152815230133142514794315791507021465817567468774789784587091999885994535058653754619647620381372543483275148787105151787326782844064720185536416121473451477393757816684580118267456510970488215312345263565438189766
d = wienerAttack(e, n)
print(d)
plaintext = pow(c, d, n)
print(str(binascii.a2b_hex(hex(plaintext)[2:]), 'utf-8'))
```

## HGAME 蛛蛛...嘿嘿♥我的蛛蛛

学习使用了 burpsuite 的爬虫工具，熟悉响应包的一些 header 内容，了解了 Referer, User-Agent 等参数。  
本题通过观察发现每个页面都有一个链接通往下一页面，借助 bp 爬虫工具进行目录爬取，获得链接尽头网页 url，再抓包观察响应头得到 flag。  

## HGAME RSA Attack

描述：  
这就是传说中的暴力美学么。  
题目给出 e, n, c 的值，可见 n 的长度非常短，直接使用 factordb 分解质因数得到 p, q。

```text
e = 65537
n = 700612512827159827368074182577656505408114629807
c = 122622425510870177715177368049049966519567512708
```

decrypt:  

```python
import gmpy2
from binascii import a2b_hex
e = 65537
n = 700612512827159827368074182577656505408114629807
c = 122622425510870177715177368049049966519567512708
q = 715800347513314032483037
p = 978782023871716954857211
d = gmpy2.invert(e, (p - 1) * (q - 1))
plaintext = pow(c, d, n)
print(str(a2b_hex(hex(plaintext)[2:]), 'utf-8'))
```

## picoCTF Easy1

Description:  
The one time pad can be cryptographically secure, but not when you know the key. Can you solve this? We've given you the encrypted flag, key, and a table to help UFJKXQZQUNB with the key of SOLVECRYPTO. Can you use this table to solve it?.  
下载 table 文件，很明显是维吉尼亚加密表，简单的维吉尼亚加密（不知道这么简单的题为什么值 100 分）  

decrypt:  

```python
def decrypt(data, key):
    assert len(data) <= len(key)
    result = ""
    for i in range(len(data)):
        if data[i].isupper():
            result+=chr((ord(data[i])-ord('A') - key[i] + 26) % 26 + ord('A'))
        elif data[i].islower():
            result+=chr((ord(data[i])-ord('a') - key[i] + 26) % 26 + ord('a'))
        else:
            result += data[i]
    return result


encrypted_flag = "UFJKXQZQUNB"
keystr = "SOLVECRYPTO"
key = list(map(lambda x: ord(x) - ord('A'), keystr))
print(decrypt(encrypted_flag, key))

```

## picoCTF Pixelated

Description:  
I have these 2 images, can you make a flag out of them? scrambled1.png scrambled2.png  
给出的是两张像素颜色杂乱无章的图片，第一次做的题型，尝试写个脚本把对应像素异或一下试试。  

发现大部分像素变成白色了，但有一小部分区域是其他淡淡的颜色，尝试把白色转为黑色看看剩下那部分的图案形状，脚本如下。  

```python
from turtle import width
import numpy as np
from PIL import Image

img1 = Image.open(r"D:\Operator\Download\picoCTF\scrambled1.png").convert('RGB')
img2 = Image.open(r"D:\Operator\Download\picoCTF\scrambled2.png")
img1ary = np.array(img1)
img2ary = np.array(img2)

res = Image.new('RGB', img1.size)

height = img1.height
width = img1.width

for i in range(height):
    for j in range(width):
        # 需要注意，img1ary[width_pos, height_pos], 横向单位在前
        R = int(img1ary[j, i, 0]) ^ int(img2ary[j, i, 0])
        G = int(img1ary[j, i, 1]) ^ int(img2ary[j, i, 1])
        B = int(img1ary[j, i, 2]) ^ int(img2ary[j, i, 2])
        if (R, G, B) == (255, 255, 255):
            (R, G, B) = (0, 0, 0)
        res.putpixel((i, j), (R, G, B))
print(np.array(res))
res.show()
```

成功在图像中得到 flag。  
