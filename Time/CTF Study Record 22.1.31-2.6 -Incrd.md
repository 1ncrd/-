# 学习记录22.1.31-2.6 -Incrd

## 线性同余方法(lcg)

一种产生伪随机数的方法。  
$x_{n+1} = (a * x_{n} + b) mod\ m$  
其中 $a, b, m$ 是产生器设定的常数。  
一些公式:  

1. $x_{n} = a^{-1} * (x_{n+1} - b)\ mod\ m$
2. $a = (x_{n+2} - x_{n+1}) * (x_{n+1} - x_{n})^{-1}\ mod\ m$
3. $b = (x_{n+1} - ax_{n}) mod\ m$
4. 设 $t_{n} = x_{n+1} - x_{n}$  
$t_{n} = (ax_{n}+b) - (ax_{n}-1+b) = at_{n-1}(mod\ m)$  
$t_{n+1}t_{n-1} - t_{n}t_{n} = (aat_{n-1}t_{n-1} - at_{n-1}at_{n-1}) = 0 (mod\ m)$  
即$T_{n} = t_{n+1}t_{n-1} - t_{n}t_{n}是m的倍数，求T_{n}, T_{n-1}$最大公因数即为m  
$m = gcd((t_{n+1}t_{n-1} - t_{n}t_{n}) , (t_{n}t_{n-2} - t_{n-1}t_{n-1}$))  

### 阶

设 $n > 1$, $a$ 和 $n$ 互质，则必有一个 $x (1 ≤ x ≤ n-1)$ 使得：$a ^ x ≡ 1 (mod\ n)$  
满足 $a ^ x ≡ 1(mod\ n)$ 的最小整数 $x$ , 称为 $a$ 模 $n$ 的阶。符号表示为 $Ord_n(a)$  
观察方程 $a ^ x ≡ 1(mod\ n)$ 根据欧拉定理，显然我们可以知道 $φ(n)$ 是方程的一个解，但它未必是最小的，所以不一定是阶，而当 $φ(n)$ 是 $a$ 模 $n$ 的阶时，我们称 $a$ 为 $n$ 的一个本原元。  

### 群

群是一个集合 $G$，连同一个运算 "·"，它结合任何两个元素 $a$ 和 $b$ 而形成另一个元素，记为 $a · b$。符号 "·" 是对具体给出的运算，比如加法的一般的占位符。要具备成为群的资格，这个集合和运算 $(G, ·)$ 必须满足叫做群公理的四个要求：  

1. 封闭性。对于所有 $G$ 中 $a, b$，运算 $a · b$ 的结果也在 $G$ 中。
2. 结合性。独于所有的 $G$ 中的 $a · b$ 和 $c$，等式 $(a · b) · c = a · (b · c)$ 成立。
3. 单位元。存在 $G$ 中的一个元素 $e$，使得对与所有 $G$ 中的元素 $a$，等式 $e · a = a · e = a$ 成立。
4. 反元素。对于每个 $G$ 中的 $a$，存在 $G$ 中的一个元素 $b$ 是的 $a · b = b · a = e$，这里的 $e$ 是单位元。

例如整数集合 和加法运算，具有以下性质

1. 对于任何两个整数 $a$ 和 b$，它们的和 $a + b$ 也是整数。这个性质叫做在加法下封闭。
2. 对于任何整数 $a, b$ 和 $c，(a + b) + c = a + (b + c)$。
3. 如果 $a$ 是任何整数，那么 $0 + a = a + 0 = a$。零叫做加法的单位元，因为把它加到任何整数都得到相同的整数。
4. 对于任何整数 $a$，存在另一个整数 b 使得 $a + b = b + a = 0$。整数 $b$ 叫做整数 $a$ 的逆元，记为 $−a$。
一个群被称为有限群，如果它有有限个元素，元素的数阶叫做群 $G$ 的阶。

例如，模 19 下 7 的阶为 3，[1, 7, 49, 343, 2401, 16807, 117649, 823543, 5764801...]={1, 7, 11, 1, 7, 11, 1, 7, 11...}这里的 1, 7, 11 循环，实际只有3个元素。

### 循环群

循环群是其所有元素都是特定元素 $a$ 的幂的群(在群运算被写为加法的时候使用术语倍数)。在乘法符号下，群的元素是:
$..., a^{−3}, a^{−2}, a^{−1}, a^0 = e, a, a^2, a^3, ...,$ 这个元素 $a$ 叫做这个群的生成元或本原元。

## Diffie-Hellman 密钥交换协议

迪菲-赫尔曼密钥交换（Diffie-Hellman key-exchange，DH）基于离散对数问题，可以让通信双方在完全没有对方任何预先信息的条件下，通过不安全信道创建一个密钥。  
这里的离散对数问题，指的是：

- 已知 $a, b, n$，计算 $a^b\ mod\ n$ 是简单的。
- 已知 $a, (a^b\ mod\ n), n$，计算 $b$ 是困难的。

Diffie-Hellman 密钥交换过程：  

1. Alice 和 Bob 选定一个素数 $p$，以及它的一个原根 $g$。
2. Alice 选择一个密钥 $a$，计算 $A = g^a$ mod p，发给 Bob。
3. Bob 选择一个密钥 $b$，计算 $B = g^b$ mod p，发给 Alice。
4. Alice 计算 $s = B^a\ mod\ p$，Bob 计算 $s = A^b\ mod\ p$，这样，Alice 和 Bob 就共享了一个密钥 $s = g^{ab}\ mod\ p$。

## ElGamal 加密算法

首先它是一个基于 Diffie-Hellman 密钥交换的非对称加密算法。它在 1985 年由塔希尔·盖莫尔提出。它可以定义在任何循环群 $G$ 上。它的安全性取决于 $G$ 上的离散对数难题。  

密钥生成：  

- Alice 和 Bob 选定一个素数 $p$，以及它的一个原根 $g$。
- Alice 选择一个私钥 $X_A$，计算公钥 $Y_A=g^{X_A}mod\ p$，公开
- Bob 选择一个私钥 $X_B$，计算公钥 $Y_B=g^{X_B}mod\ p$，公开

假如 Bob 要给 Alice 发送一条消息 $m$，加密过程：  

- Bob 计算密钥 $k=(Y_A)^{X_B}mod\ p=g^{X_AX_B}mod\ p$
- Bob 发送 $c_1=Y_B, c_2=k*m\ mod\ p$

Alice 收到密文，解密过程：  

- Alice 计算密钥 $k=(c_1)^{X_A}mod\ p=(Y_B)^{X_A}mod\ p=g^{X_AY_A}mod\ p$
- Alice 解密消息 $m=(c_2*k^{−1})mod\ p$

## HWS crypto_Elgamal

考的就是上述算法。  
elgamal.py:

```python
from Crypto.Util.number import *

def keygen(size):
    q = getPrime(80)
    k = getPrime(944)   
    while True:
        p = q * k + 1   # q = (p - 1) / k, p 为素数，故 φ(p) = p - 1 = q * k
        if isPrime(p):  # p 为素数，必存在本原根
            break
        k += 1
    g = 2
    while True:
        if pow(g, q, p) == 1:   # g ^ q ≡ 1 (mod p)
            break
        g += 1
    A = getRandomInteger(size) % q
    B = getRandomInteger(size) % q
    x = getRandomInteger(size) % q
    print(A+'\n'+B+'\n')
    h = pow(g, x, p)    # 公钥
    return (g, h, A, B, p, q), (x)


def rand(A, B, q):
    global rand_state
    rand_state, ret = (A * rand_state + B) % q, rand_state
    return ret


def encrypt(pubkey, m):
    g, h, A, B, p, q = pubkey
    assert 0 < m <= p
    r = rand(A, B, q)   # 每次加密都伪随机私钥
    c1 = pow(g, r, p)   # 发布公钥
    c2 = (m * pow(h, r, p)) % p # 密文
    return (c1, c2)

###

rand_state = getPrime(1024)
pubkey, privkey = keygen(1024)

m = bytes_to_long(FLAG)
c1, c2 = encrypt(pubkey, m)
c1_, c2_ = encrypt(pubkey, m)

print(c1, c2)
print(c1_, c2_)

###

q = getPrime(80)
print(q)
A = getRandomInteger(1024) % q
B = getRandomInteger(1024) % q

s0 = 543263588863771657634119
s1 = 628899245716105951093835
s2 = 78708024695487418261582
s3 = 598971435111109998816796
s4 = 789474285039501272453373

assert ( A * s0 + B ) % q == s1
assert ( A * s1 + B ) % q == s2
assert ( A * s2 + B ) % q == s3
assert ( A * s3 + B ) % q == s4


p = 65211247300401312530078141569304950676358489059623557848188896752173856845051471066071652073612337629832155846984721797768267868868902023383604553319793550396610085424563231688918357710337401138108050205457200940158475922063279384491022916790549837379548978141370347556053597178221402425212594060342213485311
g = 27642593390439430783453736408814717946185190497201679721975757020767271070510268596627490205095779429964809833535285315202625851326460572368018875381603399143376574281200028337681552876140857556460885848491160812604549770668188783258592940823128376128198726254875984002214053523752696104568469730021811399216
h = 54585833166051670245656045196940486576634589000609010947618047461787934106392112227019662788387352615714332234871251868259282522817042504587428441746855906297390193418159792477477443129333707197013251839952389651332058368911829464978546505729530760951698134101053626585254469108630886768357270544236516534904


c1 = 60724920570148295800083597588524297283595971970237964464679084640302395172192639331196385150232229004030419122038089044697951208850497923486467859070476427472465291810423905736825272208842988090394035980454248119048131354993356125895595138979611664707727518852984351599604226889848831071126576874892808080133
c2 = 48616294792900599931167965577794374684760165574922600262773518630884983374432147726140430372696876107933565006549344582099592376234783044818320678499613925823621554608542446585829308488452057340023780821973913517239972817669309837103043456714481646128392677624092659929248296869048674230341175765084122344264
c1_ = 42875731538109170678735196002365281622531058597803022779529275736483962610547258618168523955709341579773947887175626960699426438456382655370090748369934296474999389316334717699127421889816721511602392591677377678759026657582648354688447456509292302633971842316239774410380221303269351351929586256938787054867
c2_ = 64829024929257668640929285124747107162970460545535885047576569803424908055130477684809317765011143527867645692710091307694839524199204611328374569742391489915929451079830143261799375621377093290249652912850024319433129432676683899459510155157108727860920017105870104383111111395351496171846620163716404148070

```

先利用 lcg 算法解出 A, B 以及 q：  

```python
import gmpy2
from Crypto.Util.number import long_to_bytes

s0 = 543263588863771657634119
s1 = 628899245716105951093835
s2 = 78708024695487418261582
s3 = 598971435111109998816796
s4 = 789474285039501272453373

p = 65211247300401312530078141569304950676358489059623557848188896752173856845051471066071652073612337629832155846984721797768267868868902023383604553319793550396610085424563231688918357710337401138108050205457200940158475922063279384491022916790549837379548978141370347556053597178221402425212594060342213485311
g = 27642593390439430783453736408814717946185190497201679721975757020767271070510268596627490205095779429964809833535285315202625851326460572368018875381603399143376574281200028337681552876140857556460885848491160812604549770668188783258592940823128376128198726254875984002214053523752696104568469730021811399216
h = 54585833166051670245656045196940486576634589000609010947618047461787934106392112227019662788387352615714332234871251868259282522817042504587428441746855906297390193418159792477477443129333707197013251839952389651332058368911829464978546505729530760951698134101053626585254469108630886768357270544236516534904

c1 = 60724920570148295800083597588524297283595971970237964464679084640302395172192639331196385150232229004030419122038089044697951208850497923486467859070476427472465291810423905736825272208842988090394035980454248119048131354993356125895595138979611664707727518852984351599604226889848831071126576874892808080133
c2 = 48616294792900599931167965577794374684760165574922600262773518630884983374432147726140430372696876107933565006549344582099592376234783044818320678499613925823621554608542446585829308488452057340023780821973913517239972817669309837103043456714481646128392677624092659929248296869048674230341175765084122344264
c1_ = 42875731538109170678735196002365281622531058597803022779529275736483962610547258618168523955709341579773947887175626960699426438456382655370090748369934296474999389316334717699127421889816721511602392591677377678759026657582648354688447456509292302633971842316239774410380221303269351351929586256938787054867
c2_ = 64829024929257668640929285124747107162970460545535885047576569803424908055130477684809317765011143527867645692710091307694839524199204611328374569742391489915929451079830143261799375621377093290249652912850024319433129432676683899459510155157108727860920017105870104383111111395351496171846620163716404148070

t0 = s1 - s0
t1 = s2 - s1
t2 = s3 - s2
t3 = s4 - s3
q = gmpy2.gcd((t3*t1-t2*t2), (t2*t0-t1*t1)) # 791763770658839585424113

A = (s2 - s1) * gmpy2.invert((s1 - s0), q) % q
B = (s1 - A * s0) % q

assert ( A * s0 + B ) % q == s1
assert ( A * s1 + B ) % q == s2
assert ( A * s2 + B ) % q == s3
assert ( A * s3 + B ) % q == s4
```

这里解 q 的时候一开始想是直接对 p - 1 分解质因数，拿 factordb 上分解后没找到 80 bit 的因子，苦思良久无果，不知道是不是题目脚本有瑕疵或者误导，

---

2022.5.25: 现在知道了是因为 factordb 上对此数并没有分解完全，此数的状态为 CF: Composite, factors known，而不是 FF: Composite, fully factored，因此本题没法直接获取因子。

---

总之拿 lcg 算法是成功得到 q 了。  

最后的解密环节是搬的代码，暂时搞不明白，参考[此处](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=mouse0333&logNo=221331160503)。  

---

2022.5.25: 回来补充这一部分了，先列出以下基本关系  
$p = q *k + 1$ 即有 $q\equiv 1\ mod\ p$  
$g ^ q ≡ 1\ mod\ p$  
$h = g^x\ mod\ p$，其中 x 是私钥，是未知的。  
$c_1 = g^{r_1}\ mod\ p$  
$c_2 = m(h^{r_1}\ mod\ p)\ mod\ p$  
$\Rightarrow c_2=mh^{r_1}\ mod\ p$  
$\Rightarrow c_2=mg^{xr_1}\ mod\ p$  
${c_2}^q\equiv mg^{xr_1q}\equiv 1m\equiv m\ mod\ p$  
由 $r_2=Ar_1+B\ mod\ q$  
有 $r_2=Ar_1+b-kq$  
于是 ${c_2}^A{c_{2\_}}^{-1}h^B=m^{A-1}g^{xr_1A-xr_2+Bx}=m^{A-1}g^{xkq}\equiv m^{A-1}\ mod\ p$  
于是我们就有了 $m^{A-1}\ mod\ p$ 和 $m\ mod\ p$，运用扩展欧几里得就能计算明文了，类似于 RSA 中的共模攻击。  
这就是本题的解答原理，主要是利用了题目用线性同余来产生随机数来生成私钥，且给出了两组的密文。第一部分先根据线性同余随机数生成器产生的五个结果来逆推出随机数生成器的参数，再对两个密文进行构造，消去未知的 x，并将 m 的幂转化为两个已知的数，再运用扩展欧几里得求解结果。

---

```python
m_q = pow(c2, q, p)

m_A_1 = (pow(c2, A, p) * gmpy2.invert(c2_, p) * pow(h, B, p)) % p

_, i, j = gmpy2.gcdext(A-1, q)

if i > 0:
    tmp1 = pow(m_A_1, i, p)
else:
    tmp1 = gmpy2.invert(int(pow(m_A_1, -i, p)), p)

if j > 0:
    tmp2 = pow(m_q, j, p)
else:
    tmp2 = gmpy2.invert(int(pow(m_q, -j, p)), p)

m = (tmp1 * tmp2) % p

print(long_to_bytes(m))  # b'flag{19e9f185e6a680324cedd6e6d9382743}'
```

## RSA 选择密文攻击

背景：  
能够获得解密服务，但对于特定信息的密文解密后不会给予明文。  
该攻击方式基于乘幂保留了输入的乘法结构，

攻击方式：
此时想要获取那段特定信息可以采取如下操作：  
假设那段密文为 $C$, 对应明文为 $P$  
有 $C = P^emod\ n$  

1. 选择任意 $X∈Z^*_n$,即 X 与 n 互素
2. 计算 $Y=C\times X^e mod\ n$
3. 求得 Y 对应的解密结果 $Z=Y^d mod\ n$
4. 从而 $Z=Y^d mod\ n=(C\times X^e)^dmod\ n=(C^d\times X^{ed})mod\ n=(C^dmod\ n\times X^{ed}mod\ n)mod\ n$  
   根据
   1. $C^d≡P(mod\ n)$
   2. $ed≡1(mod\ ϕ(n))$ 即 $ed = 1 + kϕ(n), k\in N$  

    即 $Z=P\times(X^{1+kϕ(n)}mod\ n)mod\ n=P\times X\times (X^{kϕ(n)}mod\ n)mod\ n$  
    根据欧拉定理，若 $gcd(a,n)=1$，则 $a^{ϕ(n)}≡1(mod\ n)$  
    所以 $Z=P\times X mod\ n$  
    再 $Z\times X^{-1}mod\ n = P$ 即可恢复明文

## picoCTF No Padding, No Problem

Description:  
Oracles can be your best friend, they will decrypt anything, except the flag's ciphertext. How will you break it? Connect with nc mercury.picoctf.net 42248.  

nc mercury.picoctf.net 42248

```text
Welcome to the Padding Oracle Challenge
This oracle will take anything you give it and decrypt using RSA. It will not accept the ciphertext with the secret message... Good Luck!


n: 66384239355952124073071314577313366369427182552981602945351380579571417717405041914672795198579385371170964118457730093289581075701038376364337941535732255725771014092569519004311560054119558901561233842053474603382111877885831950611980694001996561889634600389895820549760036357847471220694532572936047630397
e: 65537
ciphertext: 51172569282014759512343225911416726339783922166568296522599948248993870047222389335291437561924077348194549471652030407070399493499713169033833271925021695761967385996260608790500050497409306508280838624944454920119304035484174193349449469676267882388726321404023578256430138819171927812787551637015198223678
```

解题方法即为选择密文攻击，这里取 X = 2

Script:

```python
from Crypto.Util.number import *
from pwn import *
from decimal import *
import re
import gmpy2

getcontext().prec = 1000

conn = remote('mercury.picoctf.net', 42248)
raw_text = conn.recvuntil('Give me ciphertext to decrypt:').decode()

print(raw_text)

m = re.search(r"n: ([0-9]+)\ne: ([0-9]+)\nciphertext: ([0-9]+)", raw_text)
n = int(m[1])
e = int(m[2])
c = int(m[3])

to_decrypt = c * pow(2, e, n) % n

conn.send(str(to_decrypt) + '\r\n')

print("Sent:", to_decrypt)

result = conn.recvline().decode()

print(result)

m = re.search(r"([0-9]+)", result)
result = int(Decimal(m[1]) * int(gmpy2.invert(2, n)) % n)

print(hex(result))
print('Result:', long_to_bytes(result))
```

在 kali 中运行结果

```shell
(kali㉿kali)-[~/Desktop]
└─$ python3 picoCTF_No_Padding_No_Problem.py
[+] Opening connection to mercury.picoctf.net on port 42248: Done
Welcome to the Padding Oracle Challenge
This oracle will take anything you give it and decrypt using RSA. It will not accept the ciphertext with the secret message... Good Luck!


n: 86041291473459329953006379716659918051777796460398903012566363727690459360965163067243721153129983423794995796684196993560292585998693929864574491245152094583605613544582348180908592938363707328804733436365648348480727657288869726109709884061341120332233591632048571292031332043097268277384520750337369654727
e: 65537
ciphertext: 75651758513381683955720709796334360176919973372258204290258119559971397093289721761169424507243022787813772571724276887907356587382100214057672161380888233514827141467054433104867574205908850563141728286430460257396922180371243218851580230656138326694251993023257220340823839226845320165112513381097741987236


Give me ciphertext to decrypt:
Sent: 49944291055846503584424406003117923292956449122467455979540844036914809877704528279368214213634635060317586559474205187778426149919547426704479893692012287938502876414208207082285435354919189428359976787802809842869500633245083464140875287429158325471494225044530952863208594901278737675894591303665967215747
 Here you go: 580550060391700078946913236734911770139931497702556153513487440893406629034802718534645538074938502890769716268793877259514

0x7069636f4354467b6d347962335f54683073655f6d337335346733735f3472335f646966757272656e745f373431363032327d
Result: b'picoCTF{m4yb3_Th0se_m3s54g3s_4r3_difurrent_7416022}'
[*] Closed connection to mercury.picoctf.net port 42248
```

## picoCTF spelling-quiz

Description:  
I found the flag, but my brother wrote a program to encrypt all his text files. He has a spelling quiz study guide too, but I don't know if that helps.  

encrypt.py

```python
import random
import os

files = [
    os.path.join(path, file)
    for path, dirs, files in os.walk('.')
    for file in files
    if file.split('.')[-1] == 'txt'
]

alphabet = list('abcdefghijklmnopqrstuvwxyz')
random.shuffle(shuffled := alphabet[:])
dictionary = dict(zip(alphabet, shuffled))

for filename in files:
    text = open(filename, 'r').read()
    encrypted = ''.join([
        dictionary[c]
        if c in dictionary else c
        for c in text
    ])
    open(filename, 'w').write(encrypted)
```

flag.txt  

```text
brcfxba_vfr_mid_hosbrm_iprc_exa_hoav_vwcrm
```

study-guide.txt 里应该是一堆经过同样函数加密后的单词表。  
刚开始的思路是直接统计 study-guide.txt 里的字母频率，与正常情况的字母频率进行组合代换，但是一直得不到正确结果，后来思考发现是因为网上的字母频率统计一般都是对于文章的统计，但是 study-guide.txt 中的内容是单词表，其中字母频率和文章字母频率还是有较大差别的。  

尝试的破解脚本。  

crack.py  

```python
import string

def main():
    letter_frequency_order = "eariotnslcupdmhgbfywkvxzjq"
    letter_record = dict(zip(string.ascii_lowercase, [0]*len(string.ascii_lowercase)))

    with open(r"study-guide.txt", 'r') as f:
        sample = f.read()

    letter_count = 0
    for char in sample:
        if char in string.ascii_lowercase:
            letter_record[char] += 1
            letter_count += 1

    letter_record_sorted = sorted(letter_record.items(), key=lambda item: item[1], reverse=True)

    decrypt_dict = dict(zip(dict(letter_record_sorted).keys(), letter_frequency_order))
    return decrypt_dict

def decrypt(decrypt_dict, cipher):
    res = "     "
    for i in cipher:
        if i in string.ascii_lowercase:
            res += decrypt_dict[i]
        else:
            res += i
    return res

if __name__ == '__main__':
    decrypt_dict = main()
    with open(r"flag.txt", 'r') as f:
        cipher = f.read()
    print(decrypt(decrypt_dict, cipher))
```

但是其中 r 的频率显著的高，基本可以断定是对应 e 的，然后用[在线网站](https://www.quipqiup.com/)，这个网站应该还对大量猜测结果根据其中常用词的出现进行了排序，输入加密后的 flag 和 r = e，解出 flag。  

## RSA 共模攻击

当 n 不变的情况下，知道 n, e1, e2, c1, c2 可以在不知道 d1, d2 的情况下，解出 m。  
首先假设，e1，e2互质  
即 $gcd(e1,e2)=1$  
此时则有 $e1s1+e2s2=1$，$s1、s2$ 皆为整数，但是一正一负。  
通过扩展欧几里德算法，我们可以得到该式子的一组解 $(s1,s2)$，假设 $s1$ 为正数，$s2$ 为负数。  
因为 $c1 = m^{e1}mod\ n,c2 = m^{e2}mod\ n$  
所以 $(c1^{s1}*c2^{s2})mod\ n = ((m^{e1}mod\ n)^{s1}*(m^{e2}mod\ n)^{s2})mod\ n=(m^{e1*s1}*m^{e2*s2})mod\ n=m^{e1*s1+e2*s2}mod\ n$  
根据 $e1*s1+e2*s2=1$  
上式化为 $(c1^{s1}*c2^{s2})mod\ n=m\ mod\ n=m$  
成功还原 m  

## HGAME RSA Attack2

task.py

```python
import re
from math import ceil
from Crypto.Util.number import getPrime
from libnum import s2n
from secret import flag

flag_parts = list(map(s2n, re.findall(rf".{{,{ceil(len(flag) / 3)}}}", flag)))

print("# task1")
m = flag_parts[0]
e = 65537
p = getPrime(1024)
q = getPrime(1024)
r = getPrime(1024)
n1 = p * q
c1 = pow(m, e, n1)
n2 = r * q
c2 = pow(m, e, n2)
print("e =", e)
print("n1 =", n1)
print("c1 =", c1)
print("n2 =", n2)
print("c2 =", c2)

print(n2s(pow(c1, int(invert(e, (p - 1) * (q - 1))), n1)).decode(), end = "")

print("# task2")
m = flag_parts[1]
e = 7
p = getPrime(1024)
q = getPrime(1024)
n = p * q
c = pow(m, e, n)
print("e =", e)
print("n =", n)
print("c =", c)

print("# task3")
m = flag_parts[2]
p = getPrime(1024)
q = getPrime(1024)
n = p * q
e1 = getPrime(32)
e2 = getPrime(32)
c1 = pow(m, e1, n)
c2 = pow(m, e2, n)
print("n =", n)
print("e1 =", e1)
print("c1 =", c1)
print("e2 =", e2)
print("c2 =", c2)
```

output.txt

```text
# task1
e = 65537
n1 = 14611545605107950827581005165327694782823188603151768169731431418361306231114985037775917461433925308054396970809690804073985835376464629860609710292181368600618626590498491850404503443414241455487304448344892337877422465715709154238653505141605904184985311873763495761345722155289457889686019746663293720106874227323699288277794292208957172446523420596391114891559537811029473150123641624108103676516754449492805126642552751278309634846777636042114135990516245907517377320190091400729277307636724890592155256437996566160995456743018225013851937593886086129131351582958811003596445806061492952513851932238563627194553
c1 = 965075803554932988664271816439183802328812013694203741320763105376036912584995031647672348468111310423680858101990670067065306237596121664884353679987689532305437801346923070145524106271337770666947677115752724993307387122132705797012726237073550669419110046308257408484535063515678066777681017211510981429273346928022971149411064556225001287399141306136081722471075032423079692908380267160214143720516748000734987068685104675254411687005690312116824966036851568223828884335112144637268090397158532937141122654075952730052331573980701136378212002956719295192733955673315234274064519957670199895100508623561838510479
n2 = 20937478725109983803079185450449616567464596961348727453817249035110047585580142823551289577145958127121586792878509386085178452171112455890429474457797219202827030884262273061334752493496797935346631509806685589179618367453992749753318273834113016237120686880514110415113673431170488958730203963489455418967544128619234394915820392908422974075932751838012185542968842691824203206517795693893863945100661940988455695923511777306566419373394091907349431686646485516325575494902682337518438042711296437513221448397034813099279203955535025939120139680604495486980765910892438284945450733375156933863150808369796830892363
c2 = 11536506945313747180442473461658912307154460869003392732178457643224057969838224601059836860883718459986003106970375778443725748607085620938787714081321315817144414115589952237492448483438910378865359239575169326116668030463275817609827626048962304593324479546453471881099976644410889657248346038986836461779780183411686260756776711720577053319504691373550107525296560936467435283812493396486678178020292433365898032597027338876045182743492831814175673834198345337514065596396477709839868387265840430322983945906464646824470437783271607499089791869398590557314713094674208261761299894705772513440948139429011425948090
# task2
e = 7
n = 14157878492255346300993349653813018105991884577529909522555551468374307942096214964604172734381913051273745228293930832314483466922529240958994897697475939867025561348042725919663546949015024693952641936481841552751484604123097148071800416608762258562797116583678332832015617217745966495992049762530373531163821979627361200921544223578170718741348242012164115593777700903954409103110092921578821048933346893212805071682235575813724113978341592885957767377587492202740185970828629767501662195356276862585025913615910839679860669917255271734413865211340126544199760628445054131661484184876679626946360753009512634349537
c = 10262871020519116406312674685238364023536657841034751572844570983750295909492149101500869806418603732181350082576447594766587572350246675445508931577670158295558641219582729345581697448231116318080456112516700717984731655900726388185866905989088504004805024490513718243036445638662260558477697146032055765285263446084259814560197549018044099935158351931885157616527235283229066145390964094929007056946332051364474528453970904251050605631514869007890625
# task3
n = 18819509188106230363444813350468162056164434642729404632983082518225388069544777374544142317612858448345344137372222988033366528086236635213756227816610865045924357232188768913642158448603346330462535696121739622702200540344105464126695432011739181531217582949804939555720700457350512898322376591813135311921904580338340203569582681889243452495363849558955947124975293736509426400460083981078846138740050634906824438689712748324336878791622676974341814691041262280604277357889892211717124319329666052810029131172229930723477981468761369516771720250571713027972064974999802168017946274736383148001865929719248159075729
e1 = 2519901323
c1 = 3230779726225544872531441169009307072073754578761888387983403206364548451496736513905460381907928107310030086346589351105809028599650303539607581407627819797944337398601400510560992462455048451326593993595089800150342999021874734748066692962362650540036002073748766509347649818139304363914083879918929873577706323599628031618641793074018304521243460487551364823299685052518852685706687800209505277426869140051056996242882132616256695188870782634310362973153766698286258946896866396670872451803114280846709572779780558482223393759475999103607704510618332253710503857561025613632592682931552228150171423846203875344870
e2 = 3676335737
c2 = 940818595622279161439836719641707846790294650888799822335007385854166736459283129434769062995122371073636785371800857633841379139761091890426137981113087519934854663776695944489430385663011713917022574342380155718317794204988626116362865144125136624722782309455452257758808172415884403909840651554485364309237853885251876941477098008690389600544398998669635962495989736021020715396415375890720335697504837045188626103142204474942751410819466379437091569610294575687793060945525108986660851277475079994466474859114092643797418927645726430175928247476884879817034346652560116597965191204061051401916282814886688467861
```

task1 中 n1, n2 共用了一个因数 q，可以直接用 gcd(n1, n2) 求得 q。  
`print(n2s(pow(c1, int(invert(e, (p - 1) * (q - 1))), n1)).decode(), end = "")`  

task2 中看到 e = 7很小，采用低加密指数攻击，我直接扔到以前写的脚本里跑，发现没跑出来。

```python
import gmpy2
import binascii

n = 14157878492255346300993349653813018105991884577529909522555551468374307942096214964604172734381913051273745228293930832314483466922529240958994897697475939867025561348042725919663546949015024693952641936481841552751484604123097148071800416608762258562797116583678332832015617217745966495992049762530373531163821979627361200921544223578170718741348242012164115593777700903954409103110092921578821048933346893212805071682235575813724113978341592885957767377587492202740185970828629767501662195356276862585025913615910839679860669917255271734413865211340126544199760628445054131661484184876679626946360753009512634349537
e = 7
c = 10262871020519116406312674685238364023536657841034751572844570983750295909492149101500869806418603732181350082576447594766587572350246675445508931577670158295558641219582729345581697448231116318080456112516700717984731655900726388185866905989088504004805024490513718243036445638662260558477697146032055765285263446084259814560197549018044099935158351931885157616527235283229066145390964094929007056946332051364474528453970904251050605631514869007890625

# 计算 c mod n
mod = c % n


def test():
    k = 0   # k = 1(s**t)
    while(1):
        res, is_exact = gmpy2.iroot(k * n + mod, e)
        if is_exact:
            print(f'k = {k}\nres = {res}')
            break
        k = k + 1
    return res


res = test()
plaintxt = str(binascii.a2b_hex(hex(res)[2:]), 'utf-8')
print(f'hex(res) = {hex(res)}')
print(f'plaintxt = {plaintxt}')
```

过了很久才发现是 k 的初始值设置的是 1，不是 0，然后刚好这题的密文根本没有做填充，k 改成 0 直接得出结果，所以这其实直接对 c 开 7 次方就能得出答案了（keso！）。  
`print(n2s(int(gmpy2.iroot(c, e)[0])).decode(), end = "")`  

task3 看到使用了相同的 n 和不同的 e 对明文进行加密，可以采用共模攻击。  

```python
from math import gcd 
import gmpy2 
from gmpy2 import invert 
from libnum import n2s, xgcd

n = 18819509188106230363444813350468162056164434642729404632983082518225388069544777374544142317612858448345344137372222988033366528086236635213756227816610865045924357232188768913642158448603346330462535696121739622702200540344105464126695432011739181531217582949804939555720700457350512898322376591813135311921904580338340203569582681889243452495363849558955947124975293736509426400460083981078846138740050634906824438689712748324336878791622676974341814691041262280604277357889892211717124319329666052810029131172229930723477981468761369516771720250571713027972064974999802168017946274736383148001865929719248159075729
e1 = 2519901323
c1 = 3230779726225544872531441169009307072073754578761888387983403206364548451496736513905460381907928107310030086346589351105809028599650303539607581407627819797944337398601400510560992462455048451326593993595089800150342999021874734748066692962362650540036002073748766509347649818139304363914083879918929873577706323599628031618641793074018304521243460487551364823299685052518852685706687800209505277426869140051056996242882132616256695188870782634310362973153766698286258946896866396670872451803114280846709572779780558482223393759475999103607704510618332253710503857561025613632592682931552228150171423846203875344870
e2 = 3676335737
c2 = 940818595622279161439836719641707846790294650888799822335007385854166736459283129434769062995122371073636785371800857633841379139761091890426137981113087519934854663776695944489430385663011713917022574342380155718317794204988626116362865144125136624722782309455452257758808172415884403909840651554485364309237853885251876941477098008690389600544398998669635962495989736021020715396415375890720335697504837045188626103142204474942751410819466379437091569610294575687793060945525108986660851277475079994466474859114092643797418927645726430175928247476884879817034346652560116597965191204061051401916282814886688467861

s1, s2, _ = xgcd(e1, e2)
if s1 < 0:
    s1 = -s1
    c1 = int(invert(c1, n))
if s2 < 0:
    s2 = -s2
    c2 = int(invert(c2, n))
print(n2s(pow(c1, s1, n) * pow(c2, s2, n) % n).decode())
```

## HGAME RSA Attack 3

task.py

```python
from Crypto.Util.number import getPrime
from gmpy2 import invert
from libnum import s2n
from secret import flag

p = getPrime(2048)
q = getPrime(2048)
n = p * q
d = getPrime(64)
e = invert(d, (p - 1) * (q - 1))
c = pow(s2n(flag), e, n)
print(f"n = {n}")
print(f"e = {e}")
print(f"c = {c}")
```

output.txt

```python
n = 507419170088344932990702256911694788408493968749527614421614568612944144764889717229444020813658893362983714454159980719026366361318789415279417172858536381938870379267670180128174798344744371725609827872339512302232610590888649555446972990419313445687852636305518801236132032618350847705234643521557851434711389664130274468354405273873218264222293858509477860634889001898462547712800153111774564939279190835857445378261920532206352364005840238252284065587291779196975457288580812526597185332036342330147250312262816994625317482869849388424397437470502449815132000588425028055964432298176942124697105509057090546600330760364385753313923003549670107599757996810939165300581847068233156887269181096893089415302163770884312255957584660964506028002922164767453287973102961910781312351686488047510932997937700597992705557881172640175117476017503918294534205898046483981707558521558992058512940087192655700351675718815723840568640509355338482631416345193176708501897458649841539192993142790402734898948352382350766125000186026261167277014748183012844440603384989647664190074853086693408529737767147592432979469020671772152652865219092597717869942730499507426269170189547020660681363276871874469322437194397171763927907099922324375991793759
e = 77310199867448677782081572109343472783781135641712597643597122591443011229091533516758925238949755491395489408922437493670252550920826641442189683907973926843505436730014899918587477913032286153545247063493885982941194996251799882984145155733050069564485120660716110828110738784644223519725613280140006783618393995138076030616463398284819550627612102010214315235269945251741407899692274978642663650687157736417831290404871181902463904311095448368498432147292938825418930527188720696497596867575843476810225152659244529481480993843168383016583068747733118703000287423374094051895724494193455175131120243097065270804457787026492578916584536863548445813916819417857064037664101684455000184987531252344582899589746272173970083733130106407810619258077266603898529285634495710846838011858287024329514491058790557305041389614650730267774482954666726949886313386881066593946789460028399523245777171320319444673551268379126203862576627540177888290265714418064334752499940587750374552330008143708562065940245637685833371348603338834447212248648869514585047871442060412622164276894766238383894693759347590977926306581080390685360615407766600573527565016914830132066428454738135380178959590692145577418811677639050929791996313180297924833690095
c = 165251729917394529793163344300848992394021337429474789711805041655116845722480301677817165053253655027459227404782607373107477419083333844871948673626672704233977397989843349633720167495862807995411682262559392496273163155214888276398332204954185252030616473235814999366132031184631541209554169938146205402400412307638567132128690379079483633171535375278689326189057930259534983374296873110199636558962144635514392282351103900375366360933088605794654279480277782805401749872568584335215630740265944133347038070337891035560658434763924576508969938866566235926587685108811154229747423410476421860059769485356567301897413767088823807510568561254627099309752215808220067495561412081320541540679503218232020279947159175547517811501280846596226165148013762293861131544331444165070186672186027410082671602892508739473724143698396105392623164025712124329254933353509384748403154342322725203183050328143736631333990445537119855865348221215277608372952942702104088940952142851523651639574409075484106857403651453121036577767672430612728022444370874223001778580387635197325043524719396707713385963432915855227152371800527536048555551237729690663544828830627192867570345853910196397851763591543484023134551876591248557980182981967782409054277224
```

可以看到加密指数 e 出奇地大，显然是考 Wienner Attack，之前整理过脚本，代进去直接出结果了。

crack.py

```python
import gmpy2
import binascii

# numerator(n):分子, denominator(d)：分母
def t_cf(n, d):  # 将分数 x/y 转为连分数的形式
    res = []
    while d:
        res.append(n // d)
        n, d = d, n % d
    return res


def cf(sub_res):    # 得到渐进分数的分母和分子
    n, d = 1, 0
    for i in sub_res[::-1]:  # 从后面往前循环
        d, n = n, i * n + d
    return d, n


def list_fraction(x, y):     # 列出每个渐进分数
    res = t_cf(x, y)
    res = list(map(cf, (res[0:i] for i in range(1, len(res)))))  # 将连分数的结果逐一截取以求渐进分数
    return res


def get_pq(a, b, c):  # 由p+q和pq的值通过维达定理来求解p和q(解二元一次方程)
    par = gmpy2.isqrt(b * b - 4 * a * c)  # 由上述可得，开根号一定是整数，因为有解
    x1, x2 = (-b + par) // (2 * a), (-b - par) // (2 * a)
    return x1, x2


def wienerAttack(e, n):
    for (d, k) in list_fraction(e, n):  # 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数
        if k == 0:  # 可能会出现连分数的第一个为0的情况，排除
            continue
        if (e * d - 1) % k != 0:  # ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)
            continue

        phi = (e * d - 1) // k  # 这个结果就是 φ(n)
       
        px, qy = get_pq(1, n - phi + 1, n)

        if px * qy == n:
            p, q = abs(int(px)), abs(int(qy))  # 可能会得到两个负数，负负得正未尝不会出现
            d = gmpy2.invert(e, (p - 1) * (q - 1))  # 求ed=1 (mod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d
            return d
    print("求解d失败")

e = 77310199867448677782081572109343472783781135641712597643597122591443011229091533516758925238949755491395489408922437493670252550920826641442189683907973926843505436730014899918587477913032286153545247063493885982941194996251799882984145155733050069564485120660716110828110738784644223519725613280140006783618393995138076030616463398284819550627612102010214315235269945251741407899692274978642663650687157736417831290404871181902463904311095448368498432147292938825418930527188720696497596867575843476810225152659244529481480993843168383016583068747733118703000287423374094051895724494193455175131120243097065270804457787026492578916584536863548445813916819417857064037664101684455000184987531252344582899589746272173970083733130106407810619258077266603898529285634495710846838011858287024329514491058790557305041389614650730267774482954666726949886313386881066593946789460028399523245777171320319444673551268379126203862576627540177888290265714418064334752499940587750374552330008143708562065940245637685833371348603338834447212248648869514585047871442060412622164276894766238383894693759347590977926306581080390685360615407766600573527565016914830132066428454738135380178959590692145577418811677639050929791996313180297924833690095
n = 507419170088344932990702256911694788408493968749527614421614568612944144764889717229444020813658893362983714454159980719026366361318789415279417172858536381938870379267670180128174798344744371725609827872339512302232610590888649555446972990419313445687852636305518801236132032618350847705234643521557851434711389664130274468354405273873218264222293858509477860634889001898462547712800153111774564939279190835857445378261920532206352364005840238252284065587291779196975457288580812526597185332036342330147250312262816994625317482869849388424397437470502449815132000588425028055964432298176942124697105509057090546600330760364385753313923003549670107599757996810939165300581847068233156887269181096893089415302163770884312255957584660964506028002922164767453287973102961910781312351686488047510932997937700597992705557881172640175117476017503918294534205898046483981707558521558992058512940087192655700351675718815723840568640509355338482631416345193176708501897458649841539192993142790402734898948352382350766125000186026261167277014748183012844440603384989647664190074853086693408529737767147592432979469020671772152652865219092597717869942730499507426269170189547020660681363276871874469322437194397171763927907099922324375991793759
c = 165251729917394529793163344300848992394021337429474789711805041655116845722480301677817165053253655027459227404782607373107477419083333844871948673626672704233977397989843349633720167495862807995411682262559392496273163155214888276398332204954185252030616473235814999366132031184631541209554169938146205402400412307638567132128690379079483633171535375278689326189057930259534983374296873110199636558962144635514392282351103900375366360933088605794654279480277782805401749872568584335215630740265944133347038070337891035560658434763924576508969938866566235926587685108811154229747423410476421860059769485356567301897413767088823807510568561254627099309752215808220067495561412081320541540679503218232020279947159175547517811501280846596226165148013762293861131544331444165070186672186027410082671602892508739473724143698396105392623164025712124329254933353509384748403154342322725203183050328143736631333990445537119855865348221215277608372952942702104088940952142851523651639574409075484106857403651453121036577767672430612728022444370874223001778580387635197325043524719396707713385963432915855227152371800527536048555551237729690663544828830627192867570345853910196397851763591543484023134551876591248557980182981967782409054277224
d = wienerAttack(e, n)
print(d)
plaintext = pow(c, d, n)
print(str(binascii.a2b_hex(hex(plaintext)[2:]), 'utf-8'))
```

## picoCTF Play Nice

Description:  
Not all ancient ciphers were so bad... The flag is not in standard format.  
nc mercury.picoctf.net 30568  

playfair.py  

```python
#!/usr/bin/python3 -u
import signal

SQUARE_SIZE = 6


def generate_square(alphabet):
    assert len(alphabet) == pow(SQUARE_SIZE, 2)
    matrix = []
    for i, letter in enumerate(alphabet):
        if i % SQUARE_SIZE == 0:
            row = []
        row.append(letter)
        if i % SQUARE_SIZE == (SQUARE_SIZE - 1):
            matrix.append(row)
    return matrix

def get_index(letter, matrix):
    for row in range(SQUARE_SIZE):
        for col in range(SQUARE_SIZE):
            if matrix[row][col] == letter:
                return (row, col)
    print("letter not found in matrix.")
    exit()

def encrypt_pair(pair, matrix):
    p1 = get_index(pair[0], matrix)
    p2 = get_index(pair[1], matrix)

    if p1[0] == p2[0]:
        return matrix[p1[0]][(p1[1] + 1)  % SQUARE_SIZE] + matrix[p2[0]][(p2[1] + 1)  % SQUARE_SIZE]
    elif p1[1] == p2[1]:
        return matrix[(p1[0] + 1)  % SQUARE_SIZE][p1[1]] + matrix[(p2[0] + 1)  % SQUARE_SIZE][p2[1]]
    else:
        return matrix[p1[0]][p2[1]] + matrix[p2[0]][p1[1]]

def encrypt_string(s, matrix):
    result = ""
    if len(s) % 2 == 0:
        plain = s
    else:
        plain = s + "0fkdwu6rp8zvsnlj3iytxmeh72ca9bg5o41q"[0]
    for i in range(0, len(plain), 2):
        result += encrypt_pair(plain[i:i + 2], matrix)
    return result

alphabet = open("key").read().rstrip()
m = generate_square(alphabet)
msg = open("msg").read().rstrip()
enc_msg = encrypt_string(msg, m)
print("Here is the alphabet: {}\nHere is the encrypted message: {}".format(alphabet, enc_msg))
signal.alarm(18)
resp = input("What is the plaintext message? ").rstrip()
if resp and resp == msg:
    print("Congratulations! Here's the flag: {}".format(open("flag").read()))

# https://en.wikipedia.org/wiki/Playfair_cipher

```

根据最底下的链接了解到是 Playfair cipher 加密方式，是一种使用一个关键词方格来加密字符对的加密法，可以抵抗频度分析法。  
属于对称加密，只要知道加密矩阵，就能进行解密了。  

nc mercury.picoctf.net 30568  

```text
Here is the alphabet: 0fkdwu6rp8zvsnlj3iytxmeh72ca9bg5o41q
Here is the encrypted message: herfayo7oqxrz7jwxx15ie20p40u1i
What is the plaintext message? 
```

看到给出了加密字母表，编写解密脚本也是非常简单的。

decrypt.py

```python
#!/usr/bin/python3 -u
import signal

SQUARE_SIZE = 6


def generate_square(alphabet):
    assert len(alphabet) == pow(SQUARE_SIZE, 2)
    matrix = []
    for i, letter in enumerate(alphabet):
        if i % SQUARE_SIZE == 0:
            row = []
        row.append(letter)
        if i % SQUARE_SIZE == (SQUARE_SIZE - 1):
            matrix.append(row)
    return matrix

def get_index(letter, matrix):
    for row in range(SQUARE_SIZE):
        for col in range(SQUARE_SIZE):
            if matrix[row][col] == letter:
                return (row, col)
    print("letter not found in matrix.")
    exit()

def encrypt_pair(pair, matrix):
    p1 = get_index(pair[0], matrix)
    p2 = get_index(pair[1], matrix)

    if p1[0] == p2[0]:
        return matrix[p1[0]][(p1[1] + 1)  % SQUARE_SIZE] + matrix[p2[0]][(p2[1] + 1)  % SQUARE_SIZE]
    elif p1[1] == p2[1]:
        return matrix[(p1[0] + 1)  % SQUARE_SIZE][p1[1]] + matrix[(p2[0] + 1)  % SQUARE_SIZE][p2[1]]
    else:
        return matrix[p1[0]][p2[1]] + matrix[p2[0]][p1[1]]

def decrypt_pair(pair, matrix):
    p1 = get_index(pair[0], matrix)
    p2 = get_index(pair[1], matrix)

    if p1[0] == p2[0]:
        return matrix[p1[0]][(p1[1] - 1) + SQUARE_SIZE % SQUARE_SIZE] + matrix[p2[0]][(p2[1] - 1) + SQUARE_SIZE % SQUARE_SIZE]
    elif p1[1] == p2[1]:
        return matrix[(p1[0] - 1) + SQUARE_SIZE % SQUARE_SIZE][p1[1]] + matrix[(p2[0] - 1) + SQUARE_SIZE % SQUARE_SIZE][p2[1]]
    else:
        return matrix[p1[0]][p2[1]] + matrix[p2[0]][p1[1]]

def encrypt_string(s, matrix):
    result = ""
    if len(s) % 2 == 0:
        plain = s
    else:
        plain = s + "0fkdwu6rp8zvsnlj3iytxmeh72ca9bg5o41q"[0]
    for i in range(0, len(plain), 2):
        result += encrypt_pair(plain[i:i + 2], matrix)
    return result

def decrypt_string(cipher, matrix):
    result = ""
    for i in range(0, len(cipher), 2):
        result += decrypt_pair(cipher[i:i + 2], matrix)
    return result

alphabet = "0fkdwu6rp8zvsnlj3iytxmeh72ca9bg5o41q"
m = generate_square(alphabet)
# msg = open("msg").read().rstrip()
enc_msg = "herfayo7oqxrz7jwxx15ie20p40u1i"
msg = decrypt_string(enc_msg, m)
print(msg)
# print("Here is the alphabet: {}\nHere is the encrypted message: {}".format(alphabet, enc_msg))
# # signal.alarm(18)
# resp = input("What is the plaintext message? ").rstrip()
# if resp and resp == msg:
#   print("Congratulations! Here's the flag: {}".format(open("flag").read()))

# https://en.wikipedia.org/wiki/Playfair_cipher

```

编写 `encrypt_pair(pair, matrix)` 函数的逆过程即可

## DES 加密算法

参考：<https://blog.csdn.net/bemodesty/article/details/114999946>  
基于之前了解过的 Feistel 加密结构，还是比较好理解的，在 Feistel 基础上主要的增加是 $f(R^i, K^i)$ 函数的定义。  

3-DES 使用 2 或 3 条不同的 56 位的密钥对数据进行三次加密，是DES向AES过渡的加密算法。  
3DES加密过程为：C=Ek3(Dk2(Ek1(P)))  
3DES解密过程为：P=Dk1(EK2(Dk3(C)))  

双重 DES 相较于传统 DES 并没有提升安全性，因为存在**中间相遇攻击**，破解复杂度并没有提升。  
>中途相遇攻击（英语：Meet-in-the-middle attack）是密码学上以空间换取时间的一种攻击。

## AES 加密算法

参考：<https://zhuanlan.zhihu.com/p/78913397>  

## picoCTF Double DES

Description:  
I wanted an encryption service that's more secure than regular DES, but not as slow as 3DES... The flag is not in standard format.  
nc mercury.picoctf.net 33425  

ddes.py

```python
#!/usr/bin/python3 -u
from Crypto.Cipher import DES
import binascii
import itertools
import random
import string


def pad(msg):
    '''不足 8 位倍数用空格填充'''
    block_len = 8
    over = len(msg) % block_len
    pad = block_len - over
    return (msg + " " * pad).encode()

def generate_key():
    ''' 随机六位十进制数 '''
    return pad("".join(random.choice(string.digits) for _ in range(6)))


FLAG = open("flag").read().rstrip()
KEY1 = generate_key()
KEY2 = generate_key()


def get_input():
    try:
        res = binascii.unhexlify(input("What data would you like to encrypt? ").rstrip()).decode()
    except:
        res = None
    return res

def double_encrypt(m):
    msg = pad(m)

    cipher1 = DES.new(KEY1, DES.MODE_ECB)
    enc_msg = cipher1.encrypt(msg)
    cipher2 = DES.new(KEY2, DES.MODE_ECB)
    return binascii.hexlify(cipher2.encrypt(enc_msg)).decode()


print("Here is the flag:")
print(double_encrypt(FLAG))

while True:
    inputs = get_input()
    if inputs:
        print(double_encrypt(inputs))
    else:
        print("Invalid input.")

```

题目采用了双重 DES 算法，可以采用中间相遇攻击，并且其使用的密钥长度仅 6 bytes，剩下两位使用空格填充，且这 6 bytes 的密钥由是随机的六位十进制数产生的，可能性仅有 1000000 种，又降低了破解难度。

nc mercury.picoctf.net 33425

```text
Here is the flag:
80c074bfec00cca506fec5d8a827f91957007f33fbd3bd38885ee47f9fdf1001e9c03cc8aebac245
What data would you like to encrypt? 1234
43de04570497bf0b
What data would you like to encrypt?
```

给出了加密后的 flag，并允许我们获取了明文——密文对。

crack.py

```python
import binascii
from Crypto.Cipher import DES
from tqdm import tqdm

padding = "  "
encrypted_flag = binascii.unhexlify("80c074bfec00cca506fec5d8a827f91957007f33fbd3bd38885ee47f9fdf1001e9c03cc8aebac245")

def pad(msg):
    block_len = 8
    over = len(msg) % block_len
    pad = block_len - over
    return (msg + " " * pad).encode()

custom_known_text = pad(binascii.unhexlify("1234").decode())
custom_ciphertext = binascii.unhexlify("43de04570497bf0b")

encrypt_table = {}
for key in tqdm(range(1000000), desc="Bruteforcing 1st Key"):
    key = (f"{key:06}" + padding).encode()
    cipher = DES.new(key, DES.MODE_ECB)
    encrypted_custom = cipher.encrypt(custom_known_text)
    encrypt_table[encrypted_custom] = key

decrypt_table = {}
for key in tqdm(range(1000000), desc="Bruteforcing 2nd Key"):
    key = (f"{key:06}" + padding).encode()
    cipher = DES.new(key, DES.MODE_ECB)
    decrypted_custom = cipher.decrypt(custom_ciphertext)
    decrypt_table[decrypted_custom] = key

print("Finding Key Intersection...")
encrypt_table_set = set(encrypt_table.keys())
decrypt_table_set = set(decrypt_table.keys())
for encrypt_decrypt_value in encrypt_table_set.intersection(decrypt_table_set):
    encrypt_key = encrypt_table[encrypt_decrypt_value]
    decrypt_key = decrypt_table[encrypt_decrypt_value]
    break
print("1st Key Found: %s" % encrypt_key)
print("2nd Key Found: %s" % decrypt_key)

cipher1 = DES.new(encrypt_key, DES.MODE_ECB)
cipher2 = DES.new(decrypt_key, DES.MODE_ECB)
flag_intermediate = cipher2.decrypt(encrypted_flag)
flag = cipher1.decrypt(flag_intermediate).decode()
print("Flag: %s" % flag)
```

成功解出 flag。  
